import warnings
warnings.filterwarnings("ignore", category=RuntimeWarning,
                       message="Your system is avx2 capable but pygame was not built with support for it.")

import pygame
import random
import sys
import math
import time

# Generated by Claude 2.7 sonnet one shot PROMPT:
# Write Snake game in python using pygame library. Make your game visually appealing

# Initialize pygame
pygame.init()

# Screen dimensions
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Snake Game")

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GREEN = (50, 200, 50)
DARK_GREEN = (34, 139, 34)
RED = (220, 20, 60)
BLUE = (65, 105, 225)
PURPLE = (128, 0, 128)
GOLD = (255, 215, 0)
GRAY = (100, 100, 100)
LIGHT_GRAY = (200, 200, 200)

# Game settings
GRID_SIZE = 20
GRID_WIDTH = SCREEN_WIDTH // GRID_SIZE
GRID_HEIGHT = SCREEN_HEIGHT // GRID_SIZE
SNAKE_SPEED = 10
INITIAL_SNAKE_LENGTH = 3

# Game states
MENU = 0
PLAYING = 1
GAME_OVER = 2

# Direction constants
UP = (0, -1)
DOWN = (0, 1)
LEFT = (-1, 0)
RIGHT = (1, 0)

# Fonts
font_small = pygame.font.Font(None, 36)
font_medium = pygame.font.Font(None, 48)
font_large = pygame.font.Font(None, 72)

# Load or create background
background = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
for y in range(0, SCREEN_HEIGHT, GRID_SIZE):
    for x in range(0, SCREEN_WIDTH, GRID_SIZE):
        if (x // GRID_SIZE + y // GRID_SIZE) % 2 == 0:
            pygame.draw.rect(background, (40, 40, 40), (x, y, GRID_SIZE, GRID_SIZE))
        else:
            pygame.draw.rect(background, (50, 50, 50), (x, y, GRID_SIZE, GRID_SIZE))


# Food class
class Food:
    def __init__(self):
        self.position = (0, 0)
        self.color = RED
        self.type = "normal"  # normal, speed, bonus
        self.spawn_time = 0
        self.respawn()

    def respawn(self):
        self.position = (random.randint(0, GRID_WIDTH - 1), random.randint(0, GRID_HEIGHT - 1))
        food_type = random.random()
        self.spawn_time = time.time()

        if food_type < 0.7:  # 70% normal
            self.color = RED
            self.type = "normal"
        elif food_type < 0.9:  # 20% speed
            self.color = BLUE
            self.type = "speed"
        else:  # 10% bonus
            self.color = GOLD
            self.type = "bonus"

    def draw(self):
        x, y = self.position
        rect = pygame.Rect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE)

        if self.type == "normal":
            pygame.draw.rect(screen, self.color, rect, border_radius=GRID_SIZE // 3)
        elif self.type == "speed":
            pygame.draw.rect(screen, self.color, rect, border_radius=GRID_SIZE // 3)
            inner_rect = pygame.Rect(x * GRID_SIZE + 5, y * GRID_SIZE + 5, GRID_SIZE - 10, GRID_SIZE - 10)
            pygame.draw.rect(screen, WHITE, inner_rect, border_radius=GRID_SIZE // 4)
        elif self.type == "bonus":
            # Draw a pulsating golden food
            pulse = (math.sin(time.time() * 5) + 1) / 4 + 0.5  # Values between 0.5 and 1
            pygame.draw.rect(screen, (int(GOLD[0] * pulse), int(GOLD[1] * pulse), int(GOLD[2] * pulse)),
                             rect, border_radius=GRID_SIZE // 2)


# Particle class for visual effects
class Particle:
    def __init__(self, x, y, color, size=5, lifespan=30):
        self.x = x
        self.y = y
        self.color = color
        self.size = size
        self.lifespan = lifespan
        self.velocity = (random.uniform(-1, 1), random.uniform(-1, 1))
        self.alpha = 255  # Full opacity

    def update(self):
        self.x += self.velocity[0]
        self.y += self.velocity[1]
        self.lifespan -= 1
        self.alpha = int(255 * (self.lifespan / 30))
        self.size -= 0.1
        if self.size < 0:
            self.size = 0

    def draw(self):
        if self.lifespan > 0:
            s = pygame.Surface((self.size * 2, self.size * 2), pygame.SRCALPHA)
            pygame.draw.circle(s, (self.color[0], self.color[1], self.color[2], self.alpha),
                               (self.size, self.size), self.size)
            screen.blit(s, (self.x - self.size, self.y - self.size))


# Snake class
class Snake:
    def __init__(self):
        self.reset()

    def reset(self):
        self.length = INITIAL_SNAKE_LENGTH
        self.positions = [(GRID_WIDTH // 2, GRID_HEIGHT // 2)]
        for i in range(1, self.length):
            self.positions.append((self.positions[0][0], self.positions[0][1] + i))
        self.direction = UP
        self.next_direction = UP
        self.score = 0
        self.speed_boost = 0
        self.speed_boost_time = 0
        self.particles = []

    def get_head_position(self):
        return self.positions[0]

    def change_direction(self, direction):
        # Only change direction if it's not the opposite of current direction
        if (direction[0] * -1, direction[1] * -1) != self.direction:
            self.next_direction = direction

    def move(self):
        # Apply direction change
        self.direction = self.next_direction

        # Get the head position and calculate the new position
        head = self.positions[0]
        x, y = self.direction
        new_x = (head[0] + x) % GRID_WIDTH
        new_y = (head[1] + y) % GRID_HEIGHT
        new_position = (new_x, new_y)

        # If the snake hits itself, return True (game over)
        if new_position in self.positions[1:]:
            return True

        # Insert the new position at the beginning of the snake
        self.positions.insert(0, new_position)

        # If the snake is longer than its length, remove the last position
        if len(self.positions) > self.length:
            self.positions.pop()

        # Update speed boost
        if self.speed_boost > 0 and time.time() - self.speed_boost_time > 5:
            self.speed_boost = 0

        # Add trailing particles
        if random.random() < 0.3:
            tail_x, tail_y = self.positions[-1]
            particle_x = tail_x * GRID_SIZE + GRID_SIZE // 2
            particle_y = tail_y * GRID_SIZE + GRID_SIZE // 2
            self.particles.append(Particle(particle_x, particle_y, GREEN))

        # Update particles
        for particle in self.particles[:]:
            particle.update()
            if particle.lifespan <= 0:
                self.particles.remove(particle)

        return False

    def draw(self):
        # Draw particles
        for particle in self.particles:
            particle.draw()

        # Draw snake
        for i, (x, y) in enumerate(self.positions):
            if i == 0:  # Head
                rect = pygame.Rect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE)
                pygame.draw.rect(screen, GREEN, rect, border_radius=8)

                # Draw eyes
                eye_size = GRID_SIZE // 5
                eye_offset = GRID_SIZE // 4

                # Position eyes based on direction
                if self.direction == UP:
                    left_eye = (x * GRID_SIZE + eye_offset, y * GRID_SIZE + eye_offset)
                    right_eye = (x * GRID_SIZE + GRID_SIZE - eye_offset - eye_size, y * GRID_SIZE + eye_offset)
                elif self.direction == DOWN:
                    left_eye = (x * GRID_SIZE + GRID_SIZE - eye_offset - eye_size,
                                y * GRID_SIZE + GRID_SIZE - eye_offset - eye_size)
                    right_eye = (x * GRID_SIZE + eye_offset, y * GRID_SIZE + GRID_SIZE - eye_offset - eye_size)
                elif self.direction == LEFT:
                    left_eye = (x * GRID_SIZE + eye_offset, y * GRID_SIZE + eye_offset)
                    right_eye = (x * GRID_SIZE + eye_offset, y * GRID_SIZE + GRID_SIZE - eye_offset - eye_size)
                else:  # RIGHT
                    left_eye = (x * GRID_SIZE + GRID_SIZE - eye_offset - eye_size, y * GRID_SIZE + eye_offset)
                    right_eye = (x * GRID_SIZE + GRID_SIZE - eye_offset - eye_size,
                                 y * GRID_SIZE + GRID_SIZE - eye_offset - eye_size)

                pygame.draw.rect(screen, BLACK, (*left_eye, eye_size, eye_size))
                pygame.draw.rect(screen, BLACK, (*right_eye, eye_size, eye_size))

            else:  # Body
                rect = pygame.Rect(x * GRID_SIZE + 1, y * GRID_SIZE + 1, GRID_SIZE - 2, GRID_SIZE - 2)
                if i == len(self.positions) - 1:  # Tail
                    color = DARK_GREEN
                else:
                    color = GREEN if i % 2 == 0 else DARK_GREEN
                pygame.draw.rect(screen, color, rect, border_radius=4)

    def check_collision_with_food(self, food):
        if self.get_head_position() == food.position:
            self.length += 1

            # Add particles for visual effect
            x, y = food.position
            particle_x = x * GRID_SIZE + GRID_SIZE // 2
            particle_y = y * GRID_SIZE + GRID_SIZE // 2

            # Create particles based on food type
            if food.type == "normal":
                for _ in range(10):
                    self.particles.append(Particle(particle_x, particle_y, RED))
                self.score += 10
            elif food.type == "speed":
                for _ in range(15):
                    self.particles.append(Particle(particle_x, particle_y, BLUE))
                self.speed_boost = 1
                self.speed_boost_time = time.time()
                self.score += 15
            elif food.type == "bonus":
                for _ in range(20):
                    self.particles.append(Particle(particle_x, particle_y, GOLD))
                self.score += 30

            food.respawn()
            return True
        return False


# Button class
class Button:
    def __init__(self, text, x, y, width, height, color, hover_color, text_color=WHITE):
        self.text = text
        self.rect = pygame.Rect(x, y, width, height)
        self.color = color
        self.hover_color = hover_color
        self.text_color = text_color
        self.is_hovered = False

    def draw(self):
        color = self.hover_color if self.is_hovered else self.color
        pygame.draw.rect(screen, color, self.rect, border_radius=10)
        pygame.draw.rect(screen, WHITE, self.rect, 2, border_radius=10)

        font = font_medium
        text_surface = font.render(self.text, True, self.text_color)
        text_rect = text_surface.get_rect(center=self.rect.center)
        screen.blit(text_surface, text_rect)

    def check_hover(self, pos):
        self.is_hovered = self.rect.collidepoint(pos)
        return self.is_hovered

    def is_clicked(self, pos, event):
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            return self.rect.collidepoint(pos)
        return False


# Main game function
def main():
    clock = pygame.time.Clock()

    # Initialize game objects
    snake = Snake()
    food = Food()

    # Game state
    game_state = MENU

    # Create buttons
    play_button = Button("PLAY", SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2, 200, 50, GREEN, DARK_GREEN)
    quit_button = Button("QUIT", SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2 + 70, 200, 50, RED, (180, 0, 0))
    retry_button = Button("RETRY", SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2 + 50, 200, 50, GREEN, DARK_GREEN)
    menu_button = Button("MENU", SCREEN_WIDTH // 2 - 100, SCREEN_HEIGHT // 2 + 120, 200, 50, BLUE, (30, 70, 180))

    # Game loop
    running = True
    while running:
        # Handle events
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

            # Handle key presses
            if event.type == pygame.KEYDOWN:
                if game_state == PLAYING:
                    if event.key == pygame.K_UP:
                        snake.change_direction(UP)
                    elif event.key == pygame.K_DOWN:
                        snake.change_direction(DOWN)
                    elif event.key == pygame.K_LEFT:
                        snake.change_direction(LEFT)
                    elif event.key == pygame.K_RIGHT:
                        snake.change_direction(RIGHT)
                    elif event.key == pygame.K_ESCAPE:
                        game_state = MENU
                elif game_state == MENU and event.key == pygame.K_RETURN:
                    snake.reset()
                    food.respawn()
                    game_state = PLAYING
                elif game_state == GAME_OVER and event.key == pygame.K_RETURN:
                    snake.reset()
                    food.respawn()
                    game_state = PLAYING

            # Handle mouse events
            mouse_pos = pygame.mouse.get_pos()

            if game_state == MENU:
                play_button.check_hover(mouse_pos)
                quit_button.check_hover(mouse_pos)

                if play_button.is_clicked(mouse_pos, event):
                    snake.reset()
                    food.respawn()
                    game_state = PLAYING
                elif quit_button.is_clicked(mouse_pos, event):
                    running = False

            elif game_state == GAME_OVER:
                retry_button.check_hover(mouse_pos)
                menu_button.check_hover(mouse_pos)

                if retry_button.is_clicked(mouse_pos, event):
                    snake.reset()
                    food.respawn()
                    game_state = PLAYING
                elif menu_button.is_clicked(mouse_pos, event):
                    game_state = MENU

        # Update game state
        if game_state == PLAYING:
            # Move the snake
            game_over = snake.move()
            if game_over:
                game_state = GAME_OVER

            # Check for collisions with food
            if snake.check_collision_with_food(food):
                # Food has been eaten and respawned in the check_collision method
                pass

            # Make golden food disappear after 10 seconds
            if food.type == "bonus" and time.time() - food.spawn_time > 10:
                food.respawn()

        # Draw everything
        screen.blit(background, (0, 0))

        if game_state == MENU:
            # Draw the title
            title_text = font_large.render("SNAKE GAME", True, GREEN)
            title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 4))
            screen.blit(title_text, title_rect)

            # Draw instructions
            instructions = [
                "Use arrow keys to move",
                "Eat red food to grow",
                "Blue food gives speed boost",
                "Golden food gives bonus points",
                "Don't hit yourself!"
            ]

            for i, instruction in enumerate(instructions):
                text = font_small.render(instruction, True, WHITE)
                rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 100 + i * 30))
                screen.blit(text, rect)

            # Draw buttons
            play_button.draw()
            quit_button.draw()

        elif game_state == PLAYING:
            # Draw the snake and food
            snake.draw()
            food.draw()

            # Draw the score
            score_text = font_small.render(f"Score: {snake.score}", True, WHITE)
            screen.blit(score_text, (10, 10))

            # Draw the speed boost indicator
            if snake.speed_boost > 0:
                remaining = 5 - (time.time() - snake.speed_boost_time)
                if remaining > 0:
                    boost_text = font_small.render(f"Speed Boost: {remaining:.1f}s", True, BLUE)
                    screen.blit(boost_text, (10, 50))

        elif game_state == GAME_OVER:
            # Draw game over text
            game_over_text = font_large.render("GAME OVER", True, RED)
            game_over_rect = game_over_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 4))
            screen.blit(game_over_text, game_over_rect)

            # Draw final score
            score_text = font_medium.render(f"Final Score: {snake.score}", True, WHITE)
            score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
            screen.blit(score_text, score_rect)

            # Draw buttons
            retry_button.draw()
            menu_button.draw()

        # Update the display
        pygame.display.flip()

        # Control game speed
        base_speed = SNAKE_SPEED
        if snake.speed_boost > 0 and game_state == PLAYING:
            clock.tick(base_speed * 1.5)  # 50% faster with speed boost
        else:
            clock.tick(base_speed)

    pygame.quit()
    sys.exit()


if __name__ == "__main__":
    main()